// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __rest } from "tslib";
import { RestError } from "@azure/core-rest-pipeline";
import { SpanStatusCode } from "@azure/core-tracing";
import { logger } from "./logger";
import { createSpan } from "./tracing";
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @internal
 * @param sortedArray - An array of entries sorted by `id`
 * @param unsortedArray - An array of entries that contain `id` but are not sorted
 */
export function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    for (const sortedItem of sortedArray) {
        const item = unsortedMap.get(sortedItem.id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
/**
 * @internal
 */
export function parseAssessmentIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/assessments\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const assessmentIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            assessment: parseInt(res[3])
        };
        return assessmentIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid Assessment pointer`);
    }
}
/**
 * Parses the index of the healthcare entity from a JSON pointer.
 * @param pointer - a JSON pointer representing an entity
 * @internal
 */
export function parseHealthcareEntityIndex(pointer) {
    const regex = new RegExp(/#\/results\/documents\/(\d+)\/entities\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        return parseInt(res[2]);
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid healthcare entity pointer`);
    }
}
const jsEncodingUnit = "Utf16CodeUnit";
/**
 * @internal
 */
export function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: options.stringIndexType || jsEncodingUnit });
}
/**
 * Set the stringIndexType property with default if it does not exist in x.
 * @param options - operation options bag that has a {@link StringIndexType}
 * @internal
 */
export function setStrEncodingParam(x) {
    return Object.assign(Object.assign({}, x), { stringIndexType: x.stringIndexType || jsEncodingUnit });
}
export function setStrEncodingParamValue(stringIndexType) {
    return stringIndexType || jsEncodingUnit;
}
/**
 * Set the opinion mining property
 * @internal
 */
export function setOpinionMining(x) {
    return Object.assign(Object.assign({}, x), { opinionMining: x.includeOpinionMining });
}
/**
 * Set the pii categories property
 * @internal
 */
export function setCategoriesFilter(x) {
    return Object.assign(Object.assign({}, x), { piiCategories: x.categoriesFilter });
}
export function setSentenceCount(x) {
    return Object.assign(Object.assign({}, x), { sentenceCount: x.maxSentenceCount });
}
export function setOrderBy(x) {
    return Object.assign(Object.assign({}, x), { sortBy: x.orderBy });
}
/**
 * @internal
 */
export function addParamsToTask(action) {
    const { actionName } = action, params = __rest(action, ["actionName"]);
    return { parameters: params, taskName: actionName };
}
/**
 * Set the modelVersion property with default if it does not exist in x.
 * @param options - operation options bag that has a {@link StringIndexType}
 * @internal
 */
export function setModelVersionParam(x) {
    return Object.assign(Object.assign({}, x), { modelVersion: x.modelVersion || "latest" });
}
/**
 * @internal
 */
export function getOperationId(operationLocation) {
    const lastSlashIndex = operationLocation.lastIndexOf("/");
    return operationLocation.substring(lastSlashIndex + 1);
}
function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
        message = message + ".";
    }
    return message + " " + innerMessage;
}
/**
 * @internal
 * parses incoming errors from the service and if the inner error code is
 * InvalidDocumentBatch, it exposes that as the statusCode instead.
 * @param error - the incoming error
 */
export function compileError(errorResponse) {
    var _a;
    const castErrorResponse = errorResponse;
    const topLevelError = (_a = castErrorResponse.response.parsedBody) === null || _a === void 0 ? void 0 : _a.error;
    if (!topLevelError)
        return errorResponse;
    let errorMessage = topLevelError.message || "";
    let invalidDocumentBatchCode = false;
    function unwrap(error) {
        if ((error === null || error === void 0 ? void 0 : error.innererror) !== undefined && error.innererror.message !== undefined) {
            if (error.innererror.code === "InvalidDocumentBatch") {
                invalidDocumentBatchCode = true;
            }
            errorMessage = appendReadableErrorMessage(errorMessage, error.innererror.message);
            return unwrap(error.innererror);
        }
        return error;
    }
    unwrap(topLevelError);
    return new RestError(errorMessage, {
        code: invalidDocumentBatchCode ? "InvalidDocumentBatch" : topLevelError.code,
        statusCode: castErrorResponse.statusCode
    });
}
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @internal
 * @param timeInMs - The number of milliseconds to be delayed.
 * @returns Resolved promise
 */
export function delay(timeInMs) {
    return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}
/**
 * @internal
 */
export function compose(fn1, fn2) {
    return (value) => fn2(fn1(value));
}
/**
 * @internal
 */
export async function getRawResponse(f, options) {
    const { onResponse } = options || {};
    let rawResponse = undefined;
    const flatResponse = await f(Object.assign(Object.assign({}, options), { onResponse: (response, flatResponseParam) => {
            rawResponse = response;
            onResponse === null || onResponse === void 0 ? void 0 : onResponse(response, flatResponseParam);
        } }));
    return {
        flatResponse,
        rawResponse: {
            statusCode: rawResponse.status,
            headers: rawResponse.headers.toJSON(),
            body: rawResponse.parsedBody
        }
    };
}
/**
 * @internal
 */
export async function sendGetRequest(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, spec, spanStr, options, path) {
    const { span, updatedOptions: finalOptions } = createSpan(`TextAnalyticsClient-${spanStr}`, options);
    try {
        const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => client.sendOperationRequest({ options: paramOptions }, Object.assign(Object.assign({}, spec), { path, httpMethod: "GET" })), finalOptions);
        return {
            flatResponse: flatResponse,
            rawResponse
        };
    }
    catch (e) {
        span.setStatus({
            code: SpanStatusCode.ERROR,
            message: e.message
        });
        throw e;
    }
    finally {
        span.end();
    }
}
//# sourceMappingURL=util.js.map