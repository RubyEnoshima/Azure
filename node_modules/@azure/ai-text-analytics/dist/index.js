'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@azure/core-asynciterator-polyfill');
var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var corePaging = require('@azure/core-paging');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const JobDescriptor = {
    type: {
        name: "Composite",
        className: "JobDescriptor",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalysisInput = {
    type: {
        name: "Composite",
        className: "AnalysisInput",
        modelProperties: {
            analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageBatchInput"
                }
            }
        }
    }
};
const MultiLanguageBatchInput = {
    type: {
        name: "Composite",
        className: "MultiLanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextDocumentInput"
                        }
                    }
                }
            }
        }
    }
};
const TextDocumentInput = {
    type: {
        name: "Composite",
        className: "TextDocumentInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobManifest = {
    type: {
        name: "Composite",
        className: "JobManifest",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "JobManifestTasks"
                }
            }
        }
    }
};
const JobManifestTasks = {
    type: {
        name: "Composite",
        className: "JobManifestTasks",
        modelProperties: {
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntitiesTask"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiTask"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyPhrasesTask"
                        }
                    }
                }
            },
            entityLinkingTasks: {
                serializedName: "entityLinkingTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntityLinkingTask"
                        }
                    }
                }
            },
            sentimentAnalysisTasks: {
                serializedName: "sentimentAnalysisTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentimentAnalysisTask"
                        }
                    }
                }
            },
            extractiveSummarizationTasks: {
                serializedName: "extractiveSummarizationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtractiveSummarizationTask"
                        }
                    }
                }
            },
            customEntityRecognitionTasks: {
                serializedName: "customEntityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntitiesTask"
                        }
                    }
                }
            },
            customSingleClassificationTasks: {
                serializedName: "customSingleClassificationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomSingleClassificationTask"
                        }
                    }
                }
            },
            customMultiClassificationTasks: {
                serializedName: "customMultiClassificationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomMultiClassificationTask"
                        }
                    }
                }
            }
        }
    }
};
const EntitiesTask = {
    type: {
        name: "Composite",
        className: "EntitiesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntitiesTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntitiesTaskParameters = {
    type: {
        name: "Composite",
        className: "EntitiesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiTask = {
    type: {
        name: "Composite",
        className: "PiiTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PiiTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiTaskParameters = {
    type: {
        name: "Composite",
        className: "PiiTaskParameters",
        modelProperties: {
            domain: {
                defaultValue: "none",
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: true,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            piiCategories: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "piiCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyPhrasesTask = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "KeyPhrasesTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyPhrasesTaskParameters = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EntityLinkingTask = {
    type: {
        name: "Composite",
        className: "EntityLinkingTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityLinkingTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntityLinkingTaskParameters = {
    type: {
        name: "Composite",
        className: "EntityLinkingTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentimentAnalysisTask = {
    type: {
        name: "Composite",
        className: "SentimentAnalysisTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SentimentAnalysisTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentimentAnalysisTaskParameters = {
    type: {
        name: "Composite",
        className: "SentimentAnalysisTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            opinionMining: {
                defaultValue: false,
                serializedName: "opinionMining",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtractiveSummarizationTask = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "ExtractiveSummarizationTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtractiveSummarizationTaskParameters = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            },
            sentenceCount: {
                defaultValue: 3,
                serializedName: "sentenceCount",
                type: {
                    name: "Number"
                }
            },
            sortBy: {
                defaultValue: "Offset",
                serializedName: "sortBy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntitiesTask = {
    type: {
        name: "Composite",
        className: "CustomEntitiesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomEntitiesTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntitiesTaskParameters = {
    type: {
        name: "Composite",
        className: "CustomEntitiesTaskParameters",
        modelProperties: {
            projectName: {
                serializedName: "project-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deployment-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomSingleClassificationTask = {
    type: {
        name: "Composite",
        className: "CustomSingleClassificationTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomSingleClassificationTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomSingleClassificationTaskParameters = {
    type: {
        name: "Composite",
        className: "CustomSingleClassificationTaskParameters",
        modelProperties: {
            projectName: {
                serializedName: "project-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deployment-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CustomMultiClassificationTask = {
    type: {
        name: "Composite",
        className: "CustomMultiClassificationTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "CustomMultiClassificationTaskParameters"
                }
            },
            taskName: {
                serializedName: "taskName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomMultiClassificationTaskParameters = {
    type: {
        name: "Composite",
        className: "CustomMultiClassificationTaskParameters",
        modelProperties: {
            projectName: {
                serializedName: "project-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deployment-name",
                required: true,
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: false,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextAnalyticsError = {
    type: {
        name: "Composite",
        className: "TextAnalyticsError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const JobMetadata = {
    type: {
        name: "Composite",
        className: "JobMetadata",
        modelProperties: {
            createdDateTime: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expirationDateTime: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            jobId: {
                serializedName: "jobId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling"
                    ]
                }
            }
        }
    }
};
const AnalyzeJobDisplayName = {
    type: {
        name: "Composite",
        className: "AnalyzeJobDisplayName",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TasksState = {
    type: {
        name: "Composite",
        className: "TasksState",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "TasksStateTasks"
                }
            }
        }
    }
};
const TasksStateTasks = {
    type: {
        name: "Composite",
        className: "TasksStateTasks",
        modelProperties: {
            completed: {
                serializedName: "completed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            failed: {
                serializedName: "failed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            inProgress: {
                serializedName: "inProgress",
                required: true,
                type: {
                    name: "Number"
                }
            },
            total: {
                serializedName: "total",
                required: true,
                type: {
                    name: "Number"
                }
            },
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionTasksItem"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionPiiTasksItem"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksKeyPhraseExtractionTasksItem"
                        }
                    }
                }
            },
            entityLinkingTasks: {
                serializedName: "entityLinkingTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityLinkingTasksItem"
                        }
                    }
                }
            },
            sentimentAnalysisTasks: {
                serializedName: "sentimentAnalysisTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksSentimentAnalysisTasksItem"
                        }
                    }
                }
            },
            extractiveSummarizationTasks: {
                serializedName: "extractiveSummarizationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksExtractiveSummarizationTasksItem"
                        }
                    }
                }
            },
            customEntityRecognitionTasks: {
                serializedName: "customEntityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksCustomEntityRecognitionTasksItem"
                        }
                    }
                }
            },
            customSingleClassificationTasks: {
                serializedName: "customSingleClassificationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksCustomSingleClassificationTasksItem"
                        }
                    }
                }
            },
            customMultiClassificationTasks: {
                serializedName: "customMultiClassificationTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksCustomMultiClassificationTasksItem"
                        }
                    }
                }
            }
        }
    }
};
const TaskState = {
    type: {
        name: "Composite",
        className: "TaskState",
        modelProperties: {
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            taskName: {
                serializedName: "taskName",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling"
                    ]
                }
            }
        }
    }
};
const EntitiesTaskResult = {
    type: {
        name: "Composite",
        className: "EntitiesTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntitiesResult"
                }
            }
        }
    }
};
const EntitiesResult = {
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentEntities = {
    type: {
        name: "Composite",
        className: "DocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Entity = {
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TextAnalyticsWarning = {
    type: {
        name: "Composite",
        className: "TextAnalyticsWarning",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                serializedName: "charactersCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentError = {
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                serializedName: "documentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                serializedName: "validDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                serializedName: "erroneousDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PiiTaskResult = {
    type: {
        name: "Composite",
        className: "PiiTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "PiiResult"
                }
            }
        }
    }
};
const PiiResult = {
    type: {
        name: "Composite",
        className: "PiiResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiDocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiDocumentEntities = {
    type: {
        name: "Composite",
        className: "PiiDocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            redactedText: {
                serializedName: "redactedText",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const KeyPhraseTaskResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "KeyPhraseResult"
                }
            }
        }
    }
};
const KeyPhraseResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyPhrases"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentKeyPhrases = {
    type: {
        name: "Composite",
        className: "DocumentKeyPhrases",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyPhrases: {
                serializedName: "keyPhrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const EntityLinkingTaskResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntityLinkingResult"
                }
            }
        }
    }
};
const EntityLinkingResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLinkedEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLinkedEntities = {
    type: {
        name: "Composite",
        className: "DocumentLinkedEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedEntity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LinkedEntity = {
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            matches: {
                serializedName: "matches",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Match"
                        }
                    }
                }
            },
            language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            bingEntitySearchApiId: {
                serializedName: "bingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentTaskResult = {
    type: {
        name: "Composite",
        className: "SentimentTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "SentimentResponse"
                }
            }
        }
    }
};
const SentimentResponse = {
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSentiment"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentSentiment = {
    type: {
        name: "Composite",
        className: "DocumentSentiment",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative", "mixed"]
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            sentenceSentiments: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceSentiment"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            neutral: {
                serializedName: "neutral",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            targets: {
                serializedName: "targets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceTarget"
                        }
                    }
                }
            },
            assessments: {
                serializedName: "assessments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceAssessment"
                        }
                    }
                }
            }
        }
    }
};
const SentenceTarget = {
    type: {
        name: "Composite",
        className: "SentenceTarget",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TargetRelation"
                        }
                    }
                }
            }
        }
    }
};
const TargetConfidenceScoreLabel = {
    type: {
        name: "Composite",
        className: "TargetConfidenceScoreLabel",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TargetRelation = {
    type: {
        name: "Composite",
        className: "TargetRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["assessment", "target"]
                }
            },
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentenceAssessment = {
    type: {
        name: "Composite",
        className: "SentenceAssessment",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ExtractiveSummarizationTaskResult = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "ExtractiveSummarizationResult"
                }
            }
        }
    }
};
const ExtractiveSummarizationResult = {
    type: {
        name: "Composite",
        className: "ExtractiveSummarizationResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtractedDocumentSummary"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtractedDocumentSummary = {
    type: {
        name: "Composite",
        className: "ExtractedDocumentSummary",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentences: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtractedSummarySentence"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const ExtractedSummarySentence = {
    type: {
        name: "Composite",
        className: "ExtractedSummarySentence",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            rankScore: {
                serializedName: "rankScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CustomEntitiesTaskResult = {
    type: {
        name: "Composite",
        className: "CustomEntitiesTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomEntitiesResult"
                }
            }
        }
    }
};
const CustomEntitiesResult = {
    type: {
        name: "Composite",
        className: "CustomEntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            projectName: {
                serializedName: "projectName",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomSingleClassificationTaskResult = {
    type: {
        name: "Composite",
        className: "CustomSingleClassificationTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomSingleClassificationResult"
                }
            }
        }
    }
};
const CustomSingleClassificationResult = {
    type: {
        name: "Composite",
        className: "CustomSingleClassificationResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SingleClassificationDocument"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            projectName: {
                serializedName: "projectName",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SingleClassificationDocument = {
    type: {
        name: "Composite",
        className: "SingleClassificationDocument",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            classification: {
                serializedName: "classification",
                type: {
                    name: "Composite",
                    className: "ClassificationResult"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const ClassificationResult = {
    type: {
        name: "Composite",
        className: "ClassificationResult",
        modelProperties: {
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CustomMultiClassificationTaskResult = {
    type: {
        name: "Composite",
        className: "CustomMultiClassificationTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "CustomMultiClassificationResult"
                }
            }
        }
    }
};
const CustomMultiClassificationResult = {
    type: {
        name: "Composite",
        className: "CustomMultiClassificationResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MultiClassificationDocument"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            projectName: {
                serializedName: "projectName",
                required: true,
                type: {
                    name: "String"
                }
            },
            deploymentName: {
                serializedName: "deploymentName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MultiClassificationDocument = {
    type: {
        name: "Composite",
        className: "MultiClassificationDocument",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            classifications: {
                serializedName: "classifications",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClassificationResult"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const AnalyzeJobErrorsAndStatistics = {
    type: {
        name: "Composite",
        className: "AnalyzeJobErrorsAndStatistics",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            }
        }
    }
};
const Pagination = {
    type: {
        name: "Composite",
        className: "Pagination",
        modelProperties: {
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareTaskResult = {
    type: {
        name: "Composite",
        className: "HealthcareTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "HealthcareResult"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareResult = {
    type: {
        name: "Composite",
        className: "HealthcareResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentHealthcareEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentHealthcareEntities = {
    type: {
        name: "Composite",
        className: "DocumentHealthcareEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntity"
                        }
                    }
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelation"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const HealthcareEntityProperties = {
    type: {
        name: "Composite",
        className: "HealthcareEntityProperties",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subcategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HealthcareLinkingProperties = {
    type: {
        name: "Composite",
        className: "HealthcareLinkingProperties",
        modelProperties: {
            assertion: {
                serializedName: "assertion",
                type: {
                    name: "Composite",
                    className: "HealthcareAssertion"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            links: {
                serializedName: "links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntityLink"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareAssertion = {
    type: {
        name: "Composite",
        className: "HealthcareAssertion",
        modelProperties: {
            conditionality: {
                serializedName: "conditionality",
                type: {
                    name: "Enum",
                    allowedValues: ["hypothetical", "conditional"]
                }
            },
            certainty: {
                serializedName: "certainty",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "positive",
                        "positivePossible",
                        "neutralPossible",
                        "negativePossible",
                        "negative"
                    ]
                }
            },
            association: {
                serializedName: "association",
                type: {
                    name: "Enum",
                    allowedValues: ["subject", "other"]
                }
            }
        }
    }
};
const HealthcareEntityLink = {
    type: {
        name: "Composite",
        className: "HealthcareEntityLink",
        modelProperties: {
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareRelation = {
    type: {
        name: "Composite",
        className: "HealthcareRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelationEntity"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareRelationEntity = {
    type: {
        name: "Composite",
        className: "HealthcareRelationEntity",
        modelProperties: {
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "role",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageBatchInput = {
    type: {
        name: "Composite",
        className: "LanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectLanguageInput"
                        }
                    }
                }
            }
        }
    }
};
const DetectLanguageInput = {
    type: {
        name: "Composite",
        className: "DetectLanguageInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageResult = {
    type: {
        name: "Composite",
        className: "LanguageResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            detectedLanguage: {
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const DetectedLanguage = {
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                serializedName: "iso6391Name",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeBatchInput = {
    type: {
        name: "Composite",
        className: "AnalyzeBatchInput",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobDescriptor.type.modelProperties), AnalysisInput.type.modelProperties), JobManifest.type.modelProperties)
    }
};
const AnalyzeJobMetadata = {
    type: {
        name: "Composite",
        className: "AnalyzeJobMetadata",
        modelProperties: Object.assign(Object.assign({}, JobMetadata.type.modelProperties), AnalyzeJobDisplayName.type.modelProperties)
    }
};
const HealthcareJobState = {
    type: {
        name: "Composite",
        className: "HealthcareJobState",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobMetadata.type.modelProperties), HealthcareTaskResult.type.modelProperties), Pagination.type.modelProperties)
    }
};
const AnalyzeJobState = {
    type: {
        name: "Composite",
        className: "AnalyzeJobState",
        modelProperties: Object.assign(Object.assign(Object.assign(Object.assign({}, AnalyzeJobMetadata.type.modelProperties), TasksState.type.modelProperties), AnalyzeJobErrorsAndStatistics.type.modelProperties), Pagination.type.modelProperties)
    }
};
const TasksStateTasksEntityRecognitionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntitiesTaskResult.type.modelProperties)
    }
};
const TasksStateTasksEntityRecognitionPiiTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionPiiTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), PiiTaskResult.type.modelProperties)
    }
};
const TasksStateTasksKeyPhraseExtractionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksKeyPhraseExtractionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), KeyPhraseTaskResult.type.modelProperties)
    }
};
const TasksStateTasksEntityLinkingTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityLinkingTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntityLinkingTaskResult.type.modelProperties)
    }
};
const TasksStateTasksSentimentAnalysisTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksSentimentAnalysisTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), SentimentTaskResult.type.modelProperties)
    }
};
const TasksStateTasksExtractiveSummarizationTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksExtractiveSummarizationTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), ExtractiveSummarizationTaskResult.type.modelProperties)
    }
};
const TasksStateTasksCustomEntityRecognitionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksCustomEntityRecognitionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), CustomEntitiesTaskResult.type.modelProperties)
    }
};
const TasksStateTasksCustomSingleClassificationTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksCustomSingleClassificationTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), CustomSingleClassificationTaskResult.type.modelProperties)
    }
};
const TasksStateTasksCustomMultiClassificationTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksCustomMultiClassificationTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), CustomMultiClassificationTaskResult.type.modelProperties)
    }
};
const HealthcareEntity = {
    type: {
        name: "Composite",
        className: "HealthcareEntity",
        modelProperties: Object.assign(Object.assign({}, HealthcareEntityProperties.type.modelProperties), HealthcareLinkingProperties.type.modelProperties)
    }
};
const GeneratedClientAnalyzeHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientCancelHealthJobHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientCancelHealthJobHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientHealthHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientHealthHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    JobDescriptor: JobDescriptor,
    AnalysisInput: AnalysisInput,
    MultiLanguageBatchInput: MultiLanguageBatchInput,
    TextDocumentInput: TextDocumentInput,
    JobManifest: JobManifest,
    JobManifestTasks: JobManifestTasks,
    EntitiesTask: EntitiesTask,
    EntitiesTaskParameters: EntitiesTaskParameters,
    PiiTask: PiiTask,
    PiiTaskParameters: PiiTaskParameters,
    KeyPhrasesTask: KeyPhrasesTask,
    KeyPhrasesTaskParameters: KeyPhrasesTaskParameters,
    EntityLinkingTask: EntityLinkingTask,
    EntityLinkingTaskParameters: EntityLinkingTaskParameters,
    SentimentAnalysisTask: SentimentAnalysisTask,
    SentimentAnalysisTaskParameters: SentimentAnalysisTaskParameters,
    ExtractiveSummarizationTask: ExtractiveSummarizationTask,
    ExtractiveSummarizationTaskParameters: ExtractiveSummarizationTaskParameters,
    CustomEntitiesTask: CustomEntitiesTask,
    CustomEntitiesTaskParameters: CustomEntitiesTaskParameters,
    CustomSingleClassificationTask: CustomSingleClassificationTask,
    CustomSingleClassificationTaskParameters: CustomSingleClassificationTaskParameters,
    CustomMultiClassificationTask: CustomMultiClassificationTask,
    CustomMultiClassificationTaskParameters: CustomMultiClassificationTaskParameters,
    ErrorResponse: ErrorResponse,
    TextAnalyticsError: TextAnalyticsError,
    InnerError: InnerError,
    JobMetadata: JobMetadata,
    AnalyzeJobDisplayName: AnalyzeJobDisplayName,
    TasksState: TasksState,
    TasksStateTasks: TasksStateTasks,
    TaskState: TaskState,
    EntitiesTaskResult: EntitiesTaskResult,
    EntitiesResult: EntitiesResult,
    DocumentEntities: DocumentEntities,
    Entity: Entity,
    TextAnalyticsWarning: TextAnalyticsWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    DocumentError: DocumentError,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    PiiTaskResult: PiiTaskResult,
    PiiResult: PiiResult,
    PiiDocumentEntities: PiiDocumentEntities,
    KeyPhraseTaskResult: KeyPhraseTaskResult,
    KeyPhraseResult: KeyPhraseResult,
    DocumentKeyPhrases: DocumentKeyPhrases,
    EntityLinkingTaskResult: EntityLinkingTaskResult,
    EntityLinkingResult: EntityLinkingResult,
    DocumentLinkedEntities: DocumentLinkedEntities,
    LinkedEntity: LinkedEntity,
    Match: Match,
    SentimentTaskResult: SentimentTaskResult,
    SentimentResponse: SentimentResponse,
    DocumentSentiment: DocumentSentiment,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    SentenceTarget: SentenceTarget,
    TargetConfidenceScoreLabel: TargetConfidenceScoreLabel,
    TargetRelation: TargetRelation,
    SentenceAssessment: SentenceAssessment,
    ExtractiveSummarizationTaskResult: ExtractiveSummarizationTaskResult,
    ExtractiveSummarizationResult: ExtractiveSummarizationResult,
    ExtractedDocumentSummary: ExtractedDocumentSummary,
    ExtractedSummarySentence: ExtractedSummarySentence,
    CustomEntitiesTaskResult: CustomEntitiesTaskResult,
    CustomEntitiesResult: CustomEntitiesResult,
    CustomSingleClassificationTaskResult: CustomSingleClassificationTaskResult,
    CustomSingleClassificationResult: CustomSingleClassificationResult,
    SingleClassificationDocument: SingleClassificationDocument,
    ClassificationResult: ClassificationResult,
    CustomMultiClassificationTaskResult: CustomMultiClassificationTaskResult,
    CustomMultiClassificationResult: CustomMultiClassificationResult,
    MultiClassificationDocument: MultiClassificationDocument,
    AnalyzeJobErrorsAndStatistics: AnalyzeJobErrorsAndStatistics,
    Pagination: Pagination,
    HealthcareTaskResult: HealthcareTaskResult,
    HealthcareResult: HealthcareResult,
    DocumentHealthcareEntities: DocumentHealthcareEntities,
    HealthcareEntityProperties: HealthcareEntityProperties,
    HealthcareLinkingProperties: HealthcareLinkingProperties,
    HealthcareAssertion: HealthcareAssertion,
    HealthcareEntityLink: HealthcareEntityLink,
    HealthcareRelation: HealthcareRelation,
    HealthcareRelationEntity: HealthcareRelationEntity,
    LanguageBatchInput: LanguageBatchInput,
    DetectLanguageInput: DetectLanguageInput,
    LanguageResult: LanguageResult,
    DocumentLanguage: DocumentLanguage,
    DetectedLanguage: DetectedLanguage,
    AnalyzeBatchInput: AnalyzeBatchInput,
    AnalyzeJobMetadata: AnalyzeJobMetadata,
    HealthcareJobState: HealthcareJobState,
    AnalyzeJobState: AnalyzeJobState,
    TasksStateTasksEntityRecognitionTasksItem: TasksStateTasksEntityRecognitionTasksItem,
    TasksStateTasksEntityRecognitionPiiTasksItem: TasksStateTasksEntityRecognitionPiiTasksItem,
    TasksStateTasksKeyPhraseExtractionTasksItem: TasksStateTasksKeyPhraseExtractionTasksItem,
    TasksStateTasksEntityLinkingTasksItem: TasksStateTasksEntityLinkingTasksItem,
    TasksStateTasksSentimentAnalysisTasksItem: TasksStateTasksSentimentAnalysisTasksItem,
    TasksStateTasksExtractiveSummarizationTasksItem: TasksStateTasksExtractiveSummarizationTasksItem,
    TasksStateTasksCustomEntityRecognitionTasksItem: TasksStateTasksCustomEntityRecognitionTasksItem,
    TasksStateTasksCustomSingleClassificationTasksItem: TasksStateTasksCustomSingleClassificationTasksItem,
    TasksStateTasksCustomMultiClassificationTasksItem: TasksStateTasksCustomMultiClassificationTasksItem,
    HealthcareEntity: HealthcareEntity,
    GeneratedClientAnalyzeHeaders: GeneratedClientAnalyzeHeaders,
    GeneratedClientCancelHealthJobHeaders: GeneratedClientCancelHealthJobHeaders,
    GeneratedClientHealthHeaders: GeneratedClientHealthHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: ["options", "body"],
    mapper: AnalyzeBatchInput
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "v3.2-preview.2",
        isConstant: true,
        serializedName: "ApiVersion",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const jobId = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const includeStatistics = {
    parameterPath: ["options", "includeStatistics"],
    mapper: {
        serializedName: "showStats",
        type: {
            name: "Boolean"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        defaultValue: 20,
        constraints: {
            InclusiveMaximum: 50,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        defaultValue: 0,
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const jobId1 = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const input = {
    parameterPath: "input",
    mapper: MultiLanguageBatchInput
};
const modelVersion = {
    parameterPath: ["options", "modelVersion"],
    mapper: {
        serializedName: "model-version",
        type: {
            name: "String"
        }
    }
};
const stringIndexType = {
    parameterPath: ["options", "stringIndexType"],
    mapper: {
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const loggingOptOut = {
    parameterPath: ["options", "loggingOptOut"],
    mapper: {
        serializedName: "loggingOptOut",
        type: {
            name: "Boolean"
        }
    }
};
const domain = {
    parameterPath: ["options", "domain"],
    mapper: {
        serializedName: "domain",
        type: {
            name: "String"
        }
    }
};
const piiCategories = {
    parameterPath: ["options", "piiCategories"],
    mapper: {
        constraints: {
            UniqueItems: true
        },
        serializedName: "piiCategories",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const input1 = {
    parameterPath: "input",
    mapper: LanguageBatchInput
};
const opinionMining = {
    parameterPath: ["options", "opinionMining"],
    mapper: {
        serializedName: "opinionMining",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClientContext extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-text-analytics/5.2.0-beta.2`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "{Endpoint}/text/analytics/{ApiVersion}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "v3.2-preview.2";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
     * @param options The options parameters.
     */
    analyze(options) {
        return this.sendOperationRequest({ options }, analyzeOperationSpec);
    }
    /**
     * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are
     * completed, the job will transition to the completed state and results will be available for each
     * task.
     * @param jobId Job ID for Analyze
     * @param options The options parameters.
     */
    analyzeStatus(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, analyzeStatusOperationSpec);
    }
    /**
     * Get details of the healthcare prediction job specified by the jobId.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    healthStatus(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, healthStatusOperationSpec);
    }
    /**
     * Cancel healthcare prediction job.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    cancelHealthJob(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, cancelHealthJobOperationSpec);
    }
    /**
     * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions,
     * symptoms, etc) and their relations.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    health(input, options) {
        return this.sendOperationRequest({ input, options }, healthOperationSpec);
    }
    /**
     * The API returns a list of general named entities in a given document. For the list of supported
     * entity types, check <a href="https://aka.ms/taner">Supported Entity Types in Text Analytics API</a>.
     * See the <a href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list
     * of enabled languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionGeneral(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesRecognitionGeneralOperationSpec);
    }
    /**
     * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the
     * document. For the list of supported entity types, check <a href="https://aka.ms/tanerpii">Supported
     * Entity Types in Text Analytics API</a>. See the <a href="https://aka.ms/talangs">Supported languages
     * in Text Analytics API</a> for the list of enabled languages.
     *
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionPii(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesRecognitionPiiOperationSpec);
    }
    /**
     * The API returns a list of recognized entities with links to a well known knowledge base. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesLinking(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesLinkingOperationSpec);
    }
    /**
     * The API returns a list of strings denoting the key phrases in the input text. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    keyPhrases(input, options) {
        return this.sendOperationRequest({ input, options }, keyPhrasesOperationSpec);
    }
    /**
     * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1
     * indicate 100% certainty that the identified language is true. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze for language endpoint.
     * @param options The options parameters.
     */
    languages(input, options) {
        return this.sendOperationRequest({ input, options }, languagesOperationSpec);
    }
    /**
     * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple
     * levels of granularity, start from the a document level, down to sentence and key terms (targets and
     * assessments).
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    sentiment(input, options) {
        return this.sendOperationRequest({ input, options }, sentimentOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const analyzeOperationSpec = {
    path: "/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const analyzeStatusOperationSpec = {
    path: "/analyze/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [endpoint, apiVersion, jobId],
    headerParameters: [accept],
    serializer
};
const healthStatusOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HealthcareJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [
        endpoint,
        apiVersion,
        jobId1
    ],
    headerParameters: [accept],
    serializer
};
const cancelHealthJobOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: GeneratedClientCancelHealthJobHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        jobId1
    ],
    headerParameters: [accept],
    serializer
};
const healthOperationSpec = {
    path: "/entities/health/jobs",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientHealthHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionGeneralOperationSpec = {
    path: "/entities/recognition/general",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntitiesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionPiiOperationSpec = {
    path: "/entities/recognition/pii",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PiiResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut,
        domain,
        piiCategories
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesLinkingOperationSpec = {
    path: "/entities/linking",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntityLinkingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const keyPhrasesOperationSpec = {
    path: "/keyPhrases",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: KeyPhraseResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const languagesOperationSpec = {
    path: "/languages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LanguageResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input1,
    queryParameters: [
        includeStatistics,
        modelVersion,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const sentimentOperationSpec = {
    path: "/sentiment",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SentimentResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut,
        opinionMining
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 * @internal
 */
const logger = logger$1.createClientLogger("ai-text-analytics");

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.CognitiveServices.TextAnalytics",
    namespace: "Microsoft.CognitiveServices"
});

// Copyright (c) Microsoft Corporation.
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @internal
 * @param sortedArray - An array of entries sorted by `id`
 * @param unsortedArray - An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    for (const sortedItem of sortedArray) {
        const item = unsortedMap.get(sortedItem.id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
/**
 * @internal
 */
function parseAssessmentIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/assessments\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const assessmentIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            assessment: parseInt(res[3])
        };
        return assessmentIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid Assessment pointer`);
    }
}
/**
 * Parses the index of the healthcare entity from a JSON pointer.
 * @param pointer - a JSON pointer representing an entity
 * @internal
 */
function parseHealthcareEntityIndex(pointer) {
    const regex = new RegExp(/#\/results\/documents\/(\d+)\/entities\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        return parseInt(res[2]);
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid healthcare entity pointer`);
    }
}
const jsEncodingUnit = "Utf16CodeUnit";
/**
 * @internal
 */
function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: options.stringIndexType || jsEncodingUnit });
}
/**
 * Set the stringIndexType property with default if it does not exist in x.
 * @param options - operation options bag that has a {@link StringIndexType}
 * @internal
 */
function setStrEncodingParam(x) {
    return Object.assign(Object.assign({}, x), { stringIndexType: x.stringIndexType || jsEncodingUnit });
}
function setStrEncodingParamValue(stringIndexType) {
    return stringIndexType || jsEncodingUnit;
}
/**
 * Set the opinion mining property
 * @internal
 */
function setOpinionMining(x) {
    return Object.assign(Object.assign({}, x), { opinionMining: x.includeOpinionMining });
}
/**
 * Set the pii categories property
 * @internal
 */
function setCategoriesFilter(x) {
    return Object.assign(Object.assign({}, x), { piiCategories: x.categoriesFilter });
}
function setSentenceCount(x) {
    return Object.assign(Object.assign({}, x), { sentenceCount: x.maxSentenceCount });
}
function setOrderBy(x) {
    return Object.assign(Object.assign({}, x), { sortBy: x.orderBy });
}
/**
 * @internal
 */
function addParamsToTask(action) {
    const { actionName } = action, params = tslib.__rest(action, ["actionName"]);
    return { parameters: params, taskName: actionName };
}
function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
        message = message + ".";
    }
    return message + " " + innerMessage;
}
/**
 * @internal
 * parses incoming errors from the service and if the inner error code is
 * InvalidDocumentBatch, it exposes that as the statusCode instead.
 * @param error - the incoming error
 */
function compileError(errorResponse) {
    var _a;
    const castErrorResponse = errorResponse;
    const topLevelError = (_a = castErrorResponse.response.parsedBody) === null || _a === void 0 ? void 0 : _a.error;
    if (!topLevelError)
        return errorResponse;
    let errorMessage = topLevelError.message || "";
    let invalidDocumentBatchCode = false;
    function unwrap(error) {
        if ((error === null || error === void 0 ? void 0 : error.innererror) !== undefined && error.innererror.message !== undefined) {
            if (error.innererror.code === "InvalidDocumentBatch") {
                invalidDocumentBatchCode = true;
            }
            errorMessage = appendReadableErrorMessage(errorMessage, error.innererror.message);
            return unwrap(error.innererror);
        }
        return error;
    }
    unwrap(topLevelError);
    return new coreRestPipeline.RestError(errorMessage, {
        code: invalidDocumentBatchCode ? "InvalidDocumentBatch" : topLevelError.code,
        statusCode: castErrorResponse.statusCode
    });
}
/**
 * @internal
 */
function compose(fn1, fn2) {
    return (value) => fn2(fn1(value));
}
/**
 * @internal
 */
async function getRawResponse(f, options) {
    const { onResponse } = options || {};
    let rawResponse = undefined;
    const flatResponse = await f(Object.assign(Object.assign({}, options), { onResponse: (response, flatResponseParam) => {
            rawResponse = response;
            onResponse === null || onResponse === void 0 ? void 0 : onResponse(response, flatResponseParam);
        } }));
    return {
        flatResponse,
        rawResponse: {
            statusCode: rawResponse.status,
            headers: rawResponse.headers.toJSON(),
            body: rawResponse.parsedBody
        }
    };
}
/**
 * @internal
 */
async function sendGetRequest(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, spec, spanStr, options, path) {
    const { span, updatedOptions: finalOptions } = createSpan(`TextAnalyticsClient-${spanStr}`, options);
    try {
        const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => client.sendOperationRequest({ options: paramOptions }, Object.assign(Object.assign({}, spec), { path, httpMethod: "GET" })), finalOptions);
        return {
            flatResponse: flatResponse,
            rawResponse
        };
    }
    catch (e) {
        span.setStatus({
            code: coreTracing.SpanStatusCode.ERROR,
            message: e.message
        });
        throw e;
    }
    finally {
        span.end();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Helper function for converting nested service error into
 * the unified TextAnalyticsError
 * @internal
 */
function intoTextAnalyticsError(errorModel) {
    // Return the deepest error. This will always be at most
    // one level for TextAnalytics
    if (errorModel.innererror !== undefined) {
        return intoTextAnalyticsError(errorModel.innererror);
    }
    return {
        code: errorModel.code,
        message: errorModel.message,
        target: errorModel.target
    };
}
/**
 * @internal
 */
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
    return {
        id,
        statistics,
        warnings
    };
}
/**
 * @internal
 */
function makeTextAnalyticsErrorResult(id, error) {
    return {
        id,
        error: intoTextAnalyticsError(error)
    };
}
/**
 * @internal
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array.
 * @param input - the array of documents sent to the service for processing.
 * @param response - the response received from the service.
 * @param process - a function to convert the results from one type to another.
 */
function processAndCombineSuccessfulAndErroneousDocuments(input, response, processSuccess, processError) {
    const successResults = response.documents.map(processSuccess);
    const unsortedResults = successResults.concat(response.errors.map((error) => processError(error.id, error.error)));
    return sortResponseIdObjects(input, unsortedResults);
}
/**
 * @internal
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array. It
 * also attaches statistics and modelVersion to the returned array.
 * @param input - the array of documents sent to the service for processing.
 * @param response - the response received from the service.
 */
function combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, processSuccess, processError) {
    const sorted = processAndCombineSuccessfulAndErroneousDocuments(input, response, processSuccess, processError);
    return Object.assign(sorted, {
        statistics: response.statistics,
        modelVersion: response.modelVersion
    });
}
/**
 * @internal
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array. It
 * also attaches statistics, projectName, and deploymentName to the returned array.
 * @param input - the array of documents sent to the service for processing.
 * @param response - the response received from the service.
 */
function combineSuccessfulAndErroneousDocumentsWithStatisticsAndCustomProjectInfo(input, response, processSuccess, processError) {
    const sorted = processAndCombineSuccessfulAndErroneousDocuments(input, response, processSuccess, processError);
    return Object.assign(sorted, {
        statistics: response.statistics,
        projectName: response.projectName,
        deploymentName: response.deploymentName
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeDetectLanguageResult(response) {
    const { id, warnings, statistics, detectedLanguage } = response;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
/**
 * @internal
 */
function makeDetectLanguageErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeDetectLanguageResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeDetectLanguageResult, makeDetectLanguageErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesResult(result) {
    const { entities, statistics, warnings, id } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizeCategorizedEntitiesResult, makeRecognizeCategorizedEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @param document - A document result coming from the service.
 * @internal
 */
function makeAnalyzeSentimentResult(result) {
    const { id, sentiment, confidenceScores, sentenceSentiments: sentences, warnings, statistics } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentiment,
        confidenceScores, sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, result)) });
}
/**
 * @internal
 */
function makeAnalyzeSentimentErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}
/**
 * Converts a sentence sentiment object returned by the service to another that
 * is user-friendly.
 *
 * @param sentence - The sentence sentiment object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly sentence sentiment object.
 * @internal
 */
function convertGeneratedSentenceSentiment(sentence, result) {
    return {
        confidenceScores: sentence.confidenceScores,
        sentiment: sentence.sentiment,
        text: sentence.text,
        offset: sentence.offset,
        length: sentence.length,
        opinions: sentence.targets
            ? sentence.targets.map((target) => ({
                target: {
                    confidenceScores: target.confidenceScores,
                    sentiment: target.sentiment,
                    text: target.text,
                    offset: target.offset,
                    length: target.length
                },
                assessments: target.relations
                    .filter((relation) => relation.relationType === "assessment")
                    .map((relation) => convertTargetRelationToAssessmentSentiment(relation, result))
            }))
            : []
    };
}
/**
 * Converts a target relation object returned by the service to an assessment
 * sentiment object where JSON pointers in the former are realized in the
 * latter.
 *
 * @param targetRelation - The target relation object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly assessment sentiment object.
 * @internal
 */
function convertTargetRelationToAssessmentSentiment(targetRelation, result) {
    var _a, _b;
    const assessmentPtr = targetRelation.ref;
    const assessmentIndex = parseAssessmentIndex(assessmentPtr);
    const assessment = (_b = (_a = result.sentenceSentiments) === null || _a === void 0 ? void 0 : _a[assessmentIndex.sentence].assessments) === null || _b === void 0 ? void 0 : _b[assessmentIndex.assessment];
    if (assessment !== undefined) {
        return assessment;
    }
    else {
        throw new Error(`Pointer "${assessmentPtr}" is not a valid Assessment pointer`);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeAnalyzeSentimentResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeAnalyzeSentimentResult, makeAnalyzeSentimentErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractKeyPhrasesResult(result) {
    const { id, warnings, statistics, keyPhrases } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
/**
 * @internal
 */
function makeExtractKeyPhrasesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractKeyPhrasesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeExtractKeyPhrasesResult, makeExtractKeyPhrasesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizePiiEntitiesResult(document) {
    const { id, entities, warnings, statistics, redactedText } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities,
        redactedText });
}
/**
 * @internal
 */
function makeRecognizePiiEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizePiiEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizePiiEntitiesResult, makeRecognizePiiEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesResult(result) {
    const { statistics, id, warnings, entities } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizeLinkedEntitiesResult, makeRecognizeLinkedEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * The programmatic identifier of the textAnalyticsAzureKeyCredentialPolicy.
 */
const textAnalyticsAzureKeyCredentialPolicyName = "textAnalyticsAzureKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 * @internal
 */
function textAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        name: textAnalyticsAzureKeyCredentialPolicyName,
        sendRequest(request, next) {
            request.headers.set(API_KEY_HEADER_NAME, credential.key);
            return next(request);
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a user-friendly healthcare entity represented as a node in a graph
 * @param entity - the healthcare entity returned by the service
 * @internal
 */
function makeHealthcareEntitiesWithoutNeighbors(entity) {
    var _a;
    const { category, confidenceScore, assertion, offset, text, links, subcategory, length, name } = entity;
    return {
        category,
        confidenceScore,
        assertion,
        offset,
        length,
        text,
        normalizedText: name,
        subCategory: subcategory,
        dataSources: (_a = links === null || links === void 0 ? void 0 : links.map(({ dataSource, id }) => ({ name: dataSource, entityId: id }))) !== null && _a !== void 0 ? _a : []
    };
}
/**
 * @internal
 */
function makeHealthcareRelations(entities, relations) {
    return relations.map((relation) => ({
        relationType: relation.relationType,
        roles: relation.entities.map((role) => ({
            entity: entities[parseHealthcareEntityIndex(role.ref)],
            name: role.role
        }))
    }));
}
/**
 * Creates a healthcare entity in the convenience layer from the one sent by the service.
 * @param document - incoming results sent by the service for a particular document
 * @internal
 */
function makeHealthcareEntitiesResult(document) {
    const { id, entities, relations, warnings, statistics } = document;
    const newEntities = entities.map(makeHealthcareEntitiesWithoutNeighbors);
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities: newEntities, entityRelations: makeHealthcareRelations(newEntities, relations) });
}
/**
 * @internal
 */
function makeHealthcareEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
// Consider whether the spec can be exported by code gen
const healthStatusOperationSpec$1 = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HealthcareJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [includeStatistics, top, skip],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [accept],
    serializer: serializer$1
};
/**
 * @internal
 */
class HealthLro {
    constructor(
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, baseOptions, initOptions, pollOptions, documents) {
        this.client = client;
        this.baseOptions = baseOptions;
        this.initOptions = initOptions;
        this.pollOptions = pollOptions;
        this.documents = documents;
        this.requestMethod = "POST";
        this.requestPath = "/entities/health/jobs";
    }
    async sendInitialRequest() {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyzeHealthcare", Object.assign(Object.assign({}, this.baseOptions), addStrEncodingParam(this.initOptions)));
        try {
            const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => this.client.health({ documents: this.documents }, paramOptions), finalOptions);
            return {
                flatResponse: flatResponse,
                rawResponse
            };
        }
        catch (e) {
            const exception = compileError(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: exception.message
            });
            throw exception;
        }
        finally {
            span.end();
        }
    }
    async sendPollRequest(path) {
        return sendGetRequest(this.client, healthStatusOperationSpec$1, "HealthStatus", Object.assign(Object.assign({}, this.baseOptions), this.pollOptions), path);
    }
}
/**
 * @internal
 */
function isHealthDone(response) {
    var _a;
    const castResponse = response;
    switch (castResponse.status) {
        case "notStarted":
        case "running":
            return false;
        case "failed": {
            const errors = (_a = castResponse.errors) === null || _a === void 0 ? void 0 : _a.map((e) => ` code ${e.code}, message: '${e.message}'`).join("\n");
            const message = `Healthcare analysis failed. Error(s): ${errors || ""}`;
            throw new Error(message);
        }
        default: {
            if (castResponse.results) {
                return true;
            }
            else {
                throw new Error("Healthcare action has finished but the there are no results!");
            }
        }
    }
}
/**
 * @internal
 */
function processHealthResult(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, documents, options) {
    return (result, state) => {
        const pollingURL = state.pollingURL;
        const pagedResult = {
            firstPageLink: pollingURL,
            getPage: async (pageLink, maxPageSize) => {
                const response = await sendGetRequest(client, healthStatusOperationSpec$1, "HealthStatus", 
                // if `top` is set to `undefined`, the default value will not be sent
                // as part of the request.
                maxPageSize ? Object.assign(Object.assign({}, options), { top: maxPageSize }) : options, pageLink);
                const flatResponse = response.flatResponse;
                if (flatResponse.results) {
                    return {
                        page: processAndCombineSuccessfulAndErroneousDocuments(documents, flatResponse.results, makeHealthcareEntitiesResult, makeHealthcareEntitiesErrorResult),
                        nextPageLink: flatResponse.nextLink
                    };
                }
                else {
                    throw new Error("Healthcare action has succeeded but there are no results!");
                }
            }
        };
        const pagedIterator = corePaging.getPagedAsyncIterator(pagedResult);
        return Object.assign(pagedIterator, {
            statistics: result.results.statistics,
            modelVersion: result.results.modelVersion
        });
    };
}
/**
 * @internal
 */
function updateHealthState(state, lastResponse) {
    const response = lastResponse.body;
    state.createdOn = response.createdDateTime;
    state.lastModifiedOn = response.lastUpdateDateTime;
    state.expiresOn = response.expirationDateTime;
    state.status = response.status;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeMultiCategoryClassifyResult(result) {
    const { id, warnings, statistics, classifications } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { classifications });
}
/**
 * @internal
 */
function makeMultiCategoryClassifyErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeMultiCategoryClassifyResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndCustomProjectInfo(input, response, makeMultiCategoryClassifyResult, makeMultiCategoryClassifyErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeSingleCategoryClassifyResult(result) {
    const { id, warnings, statistics, classification } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { classification });
}
/**
 * @internal
 */
function makeSingleCategoryClassifyErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeSingleCategoryClassifyResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndCustomProjectInfo(input, response, makeSingleCategoryClassifyResult, makeSingleCategoryClassifyErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractSummaryResult(result) {
    const { id, warnings, statistics, sentences } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentences: sentences.map((sentence) => (Object.assign({}, sentence))) });
}
/**
 * @internal
 */
function makeExtractSummaryErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractSummaryResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeExtractSummaryResult, makeExtractSummaryErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCustomEntitiesResult(result) {
    const { id, warnings, statistics, entities } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
/**
 * @internal
 */
function makeRecognizeCustomEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCustomEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndCustomProjectInfo(input, response, makeRecognizeCustomEntitiesResult, makeRecognizeCustomEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * Converts the service task name (in the JSON pointer in an action error) to an action type name.
 * @param serviceActionType - The task type name the service uses.
 * @returns the action type name that the package uses
 * @internal
 */
function convertTaskTypeToActionType(taskType) {
    switch (taskType) {
        case "entityRecognitionTasks": {
            return "RecognizeCategorizedEntities";
        }
        case "entityRecognitionPiiTasks": {
            return "RecognizePiiEntities";
        }
        case "keyPhraseExtractionTasks": {
            return "ExtractKeyPhrases";
        }
        case "entityLinkingTasks": {
            return "RecognizeLinkedEntities";
        }
        case "sentimentAnalysisTasks": {
            return "AnalyzeSentiment";
        }
        case "extractiveSummarizationTasks": {
            return "ExtractSummary";
        }
        case "customEntityRecognitionTasks": {
            return "RecognizeCustomEntities";
        }
        case "customSingleClassificationTasks": {
            return "SingleCategoryClassify";
        }
        case "customMultiClassificationTasks": {
            return "MultiCategoryClassify";
        }
        default: {
            throw new Error(`unexpected action type from the service: ${taskType}`);
        }
    }
}
/**
 * Converts a service action error to one with the JSON pointer converted to an action index.
 * @param erredActions - the action error the service sent
 * @returns an action error with an action type and index
 * @internal
 */
function parseActionError(erredActions) {
    if (erredActions.target) {
        const regex = new RegExp(/#\/tasks\/(entityRecognitionTasks|entityRecognitionPiiTasks|keyPhraseExtractionTasks|entityLinkingTasks|sentimentAnalysisTasks|extractiveSummarizationTasks|customEntityRecognitionTasks|customSingleClassificationTasks|customMultiClassificationTasks)\/(\d+)/);
        const result = regex.exec(erredActions.target);
        if (result !== null) {
            return {
                code: erredActions.code,
                message: erredActions.message,
                index: parseInt(result[2]),
                type: convertTaskTypeToActionType(result[1])
            };
        }
        else {
            throw new Error(`Pointer "${erredActions.target}" is not a valid action pointer`);
        }
    }
    else {
        throw new Error("expected an error with a target field referencing an action but did not get one");
    }
}
/**
 * Categorize each action error into a bucket according to its action type.
 * @param erredActions - list of action errors
 * @param recognizeEntitiesActionErrors - a list of recognize entities action errors to be filled from the errors list
 * @param recognizePiiEntitiesActionErrors - a list of recognize pii entities action errors to be filled from the errors list
 * @param extractKeyPhrasesActionErrors - a list of extract key phrases action errors to be filled from the errors list
 * @internal
 */
function categorizeActionErrors(erredActions, recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors, extractSummarySentencesActionErrors, recognizeCustomEntitiesActionErrors, singleCategoryClassifyActionErrors, multiCategoryClassifyActionErrors) {
    for (const error of erredActions) {
        const actionError = parseActionError(error);
        switch (actionError.type) {
            case "RecognizeCategorizedEntities": {
                recognizeEntitiesActionErrors.push(actionError);
                break;
            }
            case "RecognizePiiEntities": {
                recognizePiiEntitiesActionErrors.push(actionError);
                break;
            }
            case "ExtractKeyPhrases": {
                extractKeyPhrasesActionErrors.push(actionError);
                break;
            }
            case "RecognizeLinkedEntities": {
                recognizeLinkedEntitiesActionErrors.push(actionError);
                break;
            }
            case "AnalyzeSentiment": {
                analyzeSentimentActionErrors.push(actionError);
                break;
            }
            case "ExtractSummary": {
                extractSummarySentencesActionErrors.push(actionError);
                break;
            }
            case "RecognizeCustomEntities": {
                recognizeCustomEntitiesActionErrors.push(actionError);
                break;
            }
            case "SingleCategoryClassify": {
                singleCategoryClassifyActionErrors.push(actionError);
                break;
            }
            case "MultiCategoryClassify": {
                multiCategoryClassifyActionErrors.push(actionError);
                break;
            }
        }
    }
}
/**
 * @internal
 * @param error - the error the service sent for a task
 * @param lastUpdateDateTime - the time when this task failed
 */
function createErredAction(error, lastUpdateDateTime, taskName) {
    return {
        error: intoTextAnalyticsError(error),
        failedOn: lastUpdateDateTime,
        actionName: taskName
    };
}
/**
 * Creates a list of results for any action.
 * @param documents - list of input documents
 * @param makeResultsArray - a function to convert the results of a service response to the SDK's one
 * @param succeededTasks - list of succeeded action results
 * @param erredActions - list of erred actions
 * @internal
 */
function makeActionResult(documents, makeResultsArray, succeededTasks, erredActions) {
    let errorIndex = 0;
    function convertTasksToActions(actions, task) {
        const { results: actionResults, lastUpdateDateTime, taskName } = task;
        if (actionResults !== undefined) {
            const recognizeEntitiesResults = makeResultsArray(documents, actionResults);
            return [
                ...actions,
                {
                    results: recognizeEntitiesResults,
                    completedOn: lastUpdateDateTime,
                    actionName: taskName
                }
            ];
        }
        else {
            return [
                ...actions,
                createErredAction(erredActions[errorIndex++], lastUpdateDateTime, taskName)
            ];
        }
    }
    return succeededTasks.reduce(convertTasksToActions, []);
}
/**
 * Creates the user-friendly action results object for the begin analyze actions operation.
 * @param response - the begin analyze actions operation response
 * @param documents - the list of input documents
 * @returns - the user-friendly action results object
 * @internal
 */
function createAnalyzeActionsResult(response, documents) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const recognizeEntitiesActionErrors = [];
    const recognizePiiEntitiesActionErrors = [];
    const extractKeyPhrasesActionErrors = [];
    const recognizeLinkedEntitiesActionErrors = [];
    const analyzeSentimentActionErrors = [];
    const extractSummarySentencesActionErrors = [];
    const recognizeCustomEntitiesActionErrors = [];
    const singleCategoryClassifyActionErrors = [];
    const multiCategoryClassifyActionErrors = [];
    categorizeActionErrors((_a = response === null || response === void 0 ? void 0 : response.errors) !== null && _a !== void 0 ? _a : [], recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors, extractSummarySentencesActionErrors, recognizeCustomEntitiesActionErrors, singleCategoryClassifyActionErrors, multiCategoryClassifyActionErrors);
    return {
        recognizeEntitiesResults: makeActionResult(documents, makeRecognizeCategorizedEntitiesResultArray, (_b = response.tasks.entityRecognitionTasks) !== null && _b !== void 0 ? _b : [], recognizeEntitiesActionErrors),
        recognizePiiEntitiesResults: makeActionResult(documents, makeRecognizePiiEntitiesResultArray, (_c = response.tasks.entityRecognitionPiiTasks) !== null && _c !== void 0 ? _c : [], recognizePiiEntitiesActionErrors),
        extractKeyPhrasesResults: makeActionResult(documents, makeExtractKeyPhrasesResultArray, (_d = response.tasks.keyPhraseExtractionTasks) !== null && _d !== void 0 ? _d : [], extractKeyPhrasesActionErrors),
        recognizeLinkedEntitiesResults: makeActionResult(documents, makeRecognizeLinkedEntitiesResultArray, (_e = response.tasks.entityLinkingTasks) !== null && _e !== void 0 ? _e : [], recognizeLinkedEntitiesActionErrors),
        analyzeSentimentResults: makeActionResult(documents, makeAnalyzeSentimentResultArray, (_f = response.tasks.sentimentAnalysisTasks) !== null && _f !== void 0 ? _f : [], analyzeSentimentActionErrors),
        extractSummaryResults: makeActionResult(documents, makeExtractSummaryResultArray, (_g = response.tasks.extractiveSummarizationTasks) !== null && _g !== void 0 ? _g : [], extractSummarySentencesActionErrors),
        recognizeCustomEntitiesResults: makeActionResult(documents, makeRecognizeCustomEntitiesResultArray, (_h = response.tasks.customEntityRecognitionTasks) !== null && _h !== void 0 ? _h : [], recognizeCustomEntitiesActionErrors),
        singleCategoryClassifyResults: makeActionResult(documents, makeSingleCategoryClassifyResultArray, (_j = response.tasks.customSingleClassificationTasks) !== null && _j !== void 0 ? _j : [], singleCategoryClassifyActionErrors),
        multiCategoryClassifyResults: makeActionResult(documents, makeMultiCategoryClassifyResultArray, (_k = response.tasks.customMultiClassificationTasks) !== null && _k !== void 0 ? _k : [], multiCategoryClassifyActionErrors)
    };
}

// Copyright (c) Microsoft Corporation.
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
// Consider whether the spec can be exported by code gen
const analyzeStatusOperationSpec$1 = {
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [includeStatistics, top, skip],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [accept],
    serializer: serializer$2
};
/**
 * @internal
 */
class AnalyzeLro {
    constructor(
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, baseOptions, initOptions, pollOptions, documents, tasks) {
        this.client = client;
        this.baseOptions = baseOptions;
        this.initOptions = initOptions;
        this.pollOptions = pollOptions;
        this.documents = documents;
        this.tasks = tasks;
        this.requestMethod = "POST";
        this.requestPath = "/analyze";
    }
    async sendInitialRequest() {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", Object.assign(Object.assign({}, this.baseOptions), this.initOptions));
        try {
            const { flatResponse, rawResponse } = await getRawResponse((paramOptions) => this.client.analyze(Object.assign({ body: {
                    analysisInput: { documents: this.documents },
                    tasks: this.tasks,
                    displayName: this.initOptions.displayName
                } }, paramOptions)), finalOptions);
            return {
                flatResponse: flatResponse,
                rawResponse
            };
        }
        catch (e) {
            const exception = compileError(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: exception.message
            });
            throw exception;
        }
        finally {
            span.end();
        }
    }
    async sendPollRequest(path) {
        return sendGetRequest(this.client, analyzeStatusOperationSpec$1, "AnalyzeStatus", Object.assign(Object.assign({}, this.baseOptions), this.pollOptions), path);
    }
}
/**
 * @internal
 */
function isAnalyzeDone(response) {
    const castResponse = response;
    switch (castResponse.status) {
        case "notStarted":
        case "running":
            return false;
        default: {
            return true;
        }
    }
}
/**
 * @internal
 */
function processAnalyzeResult(
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
client, documents, options) {
    return (_result, state) => {
        const pollingURL = state.pollingURL;
        const pagedResult = {
            firstPageLink: pollingURL,
            getPage: async (pageLink, maxPageSize) => {
                const response = await sendGetRequest(client, analyzeStatusOperationSpec$1, "AnalyzeStatus", 
                // if `top` is set to `undefined`, the default value will not be sent
                // as part of the request.
                maxPageSize ? Object.assign(Object.assign({}, options), { top: maxPageSize }) : options, pageLink);
                const flatResponse = response.flatResponse;
                return {
                    page: createAnalyzeActionsResult(flatResponse, documents),
                    nextPageLink: flatResponse.nextLink
                };
            }
        };
        const pagedIterator = corePaging.getPagedAsyncIterator(pagedResult);
        // Attach stats if the service starts to return them
        // https://github.com/Azure/azure-sdk-for-js/issues/14139
        // state.result = Object.assign(pagedIterator, {
        //   statistics: operationStatus.statistics
        // });
        return pagedIterator;
    };
}
/**
 * @internal
 */
function updateAnalyzeState(state, lastResponse) {
    const response = lastResponse.body;
    state.createdOn = response.createdDateTime;
    state.lastModifiedOn = response.lastUpdateDateTime;
    state.expiresOn = response.expirationDateTime;
    state.status = response.status;
    state.actionsSucceededCount = response.tasks.completed;
    state.actionsFailedCount = response.tasks.failed;
    state.actionsInProgressCount = response.tasks.inProgress;
    state.displayName = response.displayName;
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
(function (PiiEntityDomain) {
    /**
     * @see {@link https://aka.ms/tanerpii} for more information.
     */
    PiiEntityDomain["PROTECTED_HEALTH_INFORMATION"] = "PHI";
})(exports.PiiEntityDomain || (exports.PiiEntityDomain = {}));
/**
 * Client class for interacting with Azure Text Analytics.
 */
class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - The URL to the TextAnalytics endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        this.client = new GeneratedClient(this.endpointUrl, internalPipelineOptions);
        const authPolicy = coreAuth.isTokenCredential(credential)
            ? coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE })
            : textAnalyticsAzureKeyCredentialPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
    }
    async detectLanguage(documents, countryHintOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const countryHint = countryHintOrOptions || this.defaultCountryHint;
            realInputs = convertToDetectLanguageInput(documents, countryHint);
            realOptions = options || {};
        }
        else {
            // Replace "none" hints with ""
            realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
            realOptions = countryHintOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", makeGeneratedDetectLanguageOptions(realOptions));
        try {
            const result = await this.client.languages({
                documents: realInputs
            }, finalOptions);
            return makeDetectLanguageResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", makeGeneratedRecognizeCategorizedEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesRecognitionGeneral({
                documents: realInputs
            }, finalOptions);
            return makeRecognizeCategorizedEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            /**
             * This special logic handles REST exception with code
             * InvalidDocumentBatch and is needed to maintain backward compatability
             * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as
             * is and include both outer and inner exception codes. However, the
             * earlier versions were throwing an exception that included the inner
             * code only.
             */
            const backwardCompatibleException = compileError(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: backwardCompatibleException.message
            });
            throw backwardCompatibleException;
        }
        finally {
            span.end();
        }
    }
    async analyzeSentiment(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", makeGeneratedAnalyzeSentimentOptions(realOptions));
        try {
            const result = await this.client.sentiment({
                documents: realInputs
            }, finalOptions);
            return makeAnalyzeSentimentResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async extractKeyPhrases(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", makeGeneratedExtractKeyPhrasesOptions(realOptions));
        try {
            const result = await this.client.keyPhrases({
                documents: realInputs
            }, finalOptions);
            return makeExtractKeyPhrasesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizePiiEntities(inputs, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (isStringArray(inputs)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(inputs, language);
            realOptions = options || {};
        }
        else {
            realInputs = inputs;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", makeGeneratedRecognizePiiEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesRecognitionPii({
                documents: realInputs
            }, finalOptions);
            return makeRecognizePiiEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizeLinkedEntities(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", makeGeneratedRecognizeLinkingEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesLinking({
                documents: realInputs
            }, finalOptions);
            return makeRecognizeLinkedEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async beginAnalyzeHealthcareEntities(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { updateIntervalInMs, resumeFrom, onResponse, disableServiceLogs, modelVersion, requestOptions, serializerOptions, abortSignal, stringIndexType, includeStatistics, tracingOptions } = realOptions;
        const lro = new HealthLro(this.client, {
            onResponse,
            requestOptions,
            serializerOptions,
            abortSignal,
            tracingOptions
        }, { loggingOptOut: disableServiceLogs, stringIndexType, modelVersion }, { includeStatistics }, realInputs);
        const poller = new coreLro.LroEngine(lro, {
            intervalInMs: updateIntervalInMs,
            resumeFrom: resumeFrom,
            processResult: processHealthResult(this.client, realInputs, {
                onResponse,
                requestOptions,
                serializerOptions,
                abortSignal,
                tracingOptions,
                includeStatistics
            }),
            isDone: isHealthDone,
            updateState: updateHealthState
        });
        await poller.poll();
        return poller;
    }
    async beginAnalyzeActions(documents, actions, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const compiledActions = compileAnalyzeInput(actions);
        const { updateIntervalInMs, resumeFrom, displayName, includeStatistics, onResponse, requestOptions, serializerOptions, abortSignal, tracingOptions } = realOptions;
        const lro = new AnalyzeLro(this.client, {
            onResponse,
            requestOptions,
            serializerOptions,
            abortSignal,
            tracingOptions
        }, { displayName }, { includeStatistics }, realInputs, compiledActions);
        const poller = new coreLro.LroEngine(lro, {
            intervalInMs: updateIntervalInMs,
            resumeFrom: resumeFrom,
            processResult: processAnalyzeResult(this.client, realInputs, {
                onResponse,
                requestOptions,
                serializerOptions,
                abortSignal,
                tracingOptions,
                includeStatistics
            }),
            isDone: isAnalyzeDone,
            updateState: updateAnalyzeState
        });
        await poller.poll();
        return poller;
    }
}
/**
 * @internal
 */
function compileAnalyzeInput(actions) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return {
        entityRecognitionPiiTasks: (_a = actions.recognizePiiEntitiesActions) === null || _a === void 0 ? void 0 : _a.map(compose(setStrEncodingParam, compose(setCategoriesFilter, addParamsToTask))),
        entityRecognitionTasks: (_b = actions.recognizeEntitiesActions) === null || _b === void 0 ? void 0 : _b.map(compose(setStrEncodingParam, addParamsToTask)),
        keyPhraseExtractionTasks: (_c = actions.extractKeyPhrasesActions) === null || _c === void 0 ? void 0 : _c.map(addParamsToTask),
        entityLinkingTasks: (_d = actions.recognizeLinkedEntitiesActions) === null || _d === void 0 ? void 0 : _d.map(compose(setStrEncodingParam, addParamsToTask)),
        sentimentAnalysisTasks: (_e = actions.analyzeSentimentActions) === null || _e === void 0 ? void 0 : _e.map(compose(setStrEncodingParam, compose(setOpinionMining, addParamsToTask))),
        extractiveSummarizationTasks: (_f = actions.extractSummaryActions) === null || _f === void 0 ? void 0 : _f.map(compose(setStrEncodingParam, compose(setSentenceCount, compose(setOrderBy, addParamsToTask)))),
        customEntityRecognitionTasks: (_g = actions.recognizeCustomEntitiesActions) === null || _g === void 0 ? void 0 : _g.map(compose(setStrEncodingParam, addParamsToTask)),
        customSingleClassificationTasks: (_h = actions.singleCategoryClassifyActions) === null || _h === void 0 ? void 0 : _h.map(addParamsToTask),
        customMultiClassificationTasks: (_j = actions.multiCategoryClassifyActions) === null || _j === void 0 ? void 0 : _j.map(addParamsToTask)
    };
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
/**
 * @internal
 */
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
/**
 * @internal
 */
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}
/**
 * Creates the options the service expects for the analyze sentiment API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedAnalyzeSentimentOptions(params) {
    return {
        abortSignal: params.abortSignal,
        opinionMining: params.includeOpinionMining,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize pii entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizePiiEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        domain: params.domainFilter,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        piiCategories: params.categoriesFilter,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizeCategorizedEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the detect language API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedDetectLanguageOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the extract key phrases API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedExtractKeyPhrasesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize linked entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizeLinkingEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType)
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link StringIndexType} that the service accepts. */
var KnownStringIndexType;
(function (KnownStringIndexType) {
    /** Returned offset and length values will correspond to TextElements (Graphemes and Grapheme clusters) confirming to the Unicode 8.0.0 standard. Use this option if your application is written in .Net Framework or .Net Core and you will be using StringInfo. */
    KnownStringIndexType["TextElementV8"] = "TextElement_v8";
    /** Returned offset and length values will correspond to Unicode code points. Use this option if your application is written in a language that support Unicode, for example Python. */
    KnownStringIndexType["UnicodeCodePoint"] = "UnicodeCodePoint";
    /** Returned offset and length values will correspond to UTF-16 code units. Use this option if your application is written in a language that support Unicode, for example Java, JavaScript. */
    KnownStringIndexType["Utf16CodeUnit"] = "Utf16CodeUnit";
})(KnownStringIndexType || (KnownStringIndexType = {}));
/** Known values of {@link PiiTaskParametersDomain} that the service accepts. */
var KnownPiiTaskParametersDomain;
(function (KnownPiiTaskParametersDomain) {
    KnownPiiTaskParametersDomain["Phi"] = "phi";
    KnownPiiTaskParametersDomain["None"] = "none";
})(KnownPiiTaskParametersDomain || (KnownPiiTaskParametersDomain = {}));
/** Known values of {@link PiiCategory} that the service accepts. */
var KnownPiiCategory;
(function (KnownPiiCategory) {
    KnownPiiCategory["ABARoutingNumber"] = "ABARoutingNumber";
    KnownPiiCategory["ARNationalIdentityNumber"] = "ARNationalIdentityNumber";
    KnownPiiCategory["AUBankAccountNumber"] = "AUBankAccountNumber";
    KnownPiiCategory["AUDriversLicenseNumber"] = "AUDriversLicenseNumber";
    KnownPiiCategory["AUMedicalAccountNumber"] = "AUMedicalAccountNumber";
    KnownPiiCategory["AUPassportNumber"] = "AUPassportNumber";
    KnownPiiCategory["AUTaxFileNumber"] = "AUTaxFileNumber";
    KnownPiiCategory["AUBusinessNumber"] = "AUBusinessNumber";
    KnownPiiCategory["AUCompanyNumber"] = "AUCompanyNumber";
    KnownPiiCategory["ATIdentityCard"] = "ATIdentityCard";
    KnownPiiCategory["ATTaxIdentificationNumber"] = "ATTaxIdentificationNumber";
    KnownPiiCategory["ATValueAddedTaxNumber"] = "ATValueAddedTaxNumber";
    KnownPiiCategory["AzureDocumentDBAuthKey"] = "AzureDocumentDBAuthKey";
    KnownPiiCategory["AzureIaasDatabaseConnectionAndSQLString"] = "AzureIAASDatabaseConnectionAndSQLString";
    KnownPiiCategory["AzureIoTConnectionString"] = "AzureIoTConnectionString";
    KnownPiiCategory["AzurePublishSettingPassword"] = "AzurePublishSettingPassword";
    KnownPiiCategory["AzureRedisCacheString"] = "AzureRedisCacheString";
    KnownPiiCategory["AzureSAS"] = "AzureSAS";
    KnownPiiCategory["AzureServiceBusString"] = "AzureServiceBusString";
    KnownPiiCategory["AzureStorageAccountKey"] = "AzureStorageAccountKey";
    KnownPiiCategory["AzureStorageAccountGeneric"] = "AzureStorageAccountGeneric";
    KnownPiiCategory["BENationalNumber"] = "BENationalNumber";
    KnownPiiCategory["BENationalNumberV2"] = "BENationalNumberV2";
    KnownPiiCategory["BEValueAddedTaxNumber"] = "BEValueAddedTaxNumber";
    KnownPiiCategory["BrcpfNumber"] = "BRCPFNumber";
    KnownPiiCategory["BRLegalEntityNumber"] = "BRLegalEntityNumber";
    KnownPiiCategory["BRNationalIdrg"] = "BRNationalIDRG";
    KnownPiiCategory["BGUniformCivilNumber"] = "BGUniformCivilNumber";
    KnownPiiCategory["CABankAccountNumber"] = "CABankAccountNumber";
    KnownPiiCategory["CADriversLicenseNumber"] = "CADriversLicenseNumber";
    KnownPiiCategory["CAHealthServiceNumber"] = "CAHealthServiceNumber";
    KnownPiiCategory["CAPassportNumber"] = "CAPassportNumber";
    KnownPiiCategory["CAPersonalHealthIdentification"] = "CAPersonalHealthIdentification";
    KnownPiiCategory["CASocialInsuranceNumber"] = "CASocialInsuranceNumber";
    KnownPiiCategory["CLIdentityCardNumber"] = "CLIdentityCardNumber";
    KnownPiiCategory["CNResidentIdentityCardNumber"] = "CNResidentIdentityCardNumber";
    KnownPiiCategory["CreditCardNumber"] = "CreditCardNumber";
    KnownPiiCategory["HRIdentityCardNumber"] = "HRIdentityCardNumber";
    KnownPiiCategory["HRNationalIDNumber"] = "HRNationalIDNumber";
    KnownPiiCategory["HRPersonalIdentificationNumber"] = "HRPersonalIdentificationNumber";
    KnownPiiCategory["HRPersonalIdentificationOIBNumberV2"] = "HRPersonalIdentificationOIBNumberV2";
    KnownPiiCategory["CYIdentityCard"] = "CYIdentityCard";
    KnownPiiCategory["CYTaxIdentificationNumber"] = "CYTaxIdentificationNumber";
    KnownPiiCategory["CZPersonalIdentityNumber"] = "CZPersonalIdentityNumber";
    KnownPiiCategory["CZPersonalIdentityV2"] = "CZPersonalIdentityV2";
    KnownPiiCategory["DKPersonalIdentificationNumber"] = "DKPersonalIdentificationNumber";
    KnownPiiCategory["DKPersonalIdentificationV2"] = "DKPersonalIdentificationV2";
    KnownPiiCategory["DrugEnforcementAgencyNumber"] = "DrugEnforcementAgencyNumber";
    KnownPiiCategory["EEPersonalIdentificationCode"] = "EEPersonalIdentificationCode";
    KnownPiiCategory["EUDebitCardNumber"] = "EUDebitCardNumber";
    KnownPiiCategory["EUDriversLicenseNumber"] = "EUDriversLicenseNumber";
    KnownPiiCategory["EugpsCoordinates"] = "EUGPSCoordinates";
    KnownPiiCategory["EUNationalIdentificationNumber"] = "EUNationalIdentificationNumber";
    KnownPiiCategory["EUPassportNumber"] = "EUPassportNumber";
    KnownPiiCategory["EUSocialSecurityNumber"] = "EUSocialSecurityNumber";
    KnownPiiCategory["EUTaxIdentificationNumber"] = "EUTaxIdentificationNumber";
    KnownPiiCategory["FIEuropeanHealthNumber"] = "FIEuropeanHealthNumber";
    KnownPiiCategory["FINationalID"] = "FINationalID";
    KnownPiiCategory["FINationalIDV2"] = "FINationalIDV2";
    KnownPiiCategory["FIPassportNumber"] = "FIPassportNumber";
    KnownPiiCategory["FRDriversLicenseNumber"] = "FRDriversLicenseNumber";
    KnownPiiCategory["FRHealthInsuranceNumber"] = "FRHealthInsuranceNumber";
    KnownPiiCategory["FRNationalID"] = "FRNationalID";
    KnownPiiCategory["FRPassportNumber"] = "FRPassportNumber";
    KnownPiiCategory["FRSocialSecurityNumber"] = "FRSocialSecurityNumber";
    KnownPiiCategory["FRTaxIdentificationNumber"] = "FRTaxIdentificationNumber";
    KnownPiiCategory["FRValueAddedTaxNumber"] = "FRValueAddedTaxNumber";
    KnownPiiCategory["DEDriversLicenseNumber"] = "DEDriversLicenseNumber";
    KnownPiiCategory["DEPassportNumber"] = "DEPassportNumber";
    KnownPiiCategory["DEIdentityCardNumber"] = "DEIdentityCardNumber";
    KnownPiiCategory["DETaxIdentificationNumber"] = "DETaxIdentificationNumber";
    KnownPiiCategory["DEValueAddedNumber"] = "DEValueAddedNumber";
    KnownPiiCategory["GRNationalIDCard"] = "GRNationalIDCard";
    KnownPiiCategory["GRNationalIDV2"] = "GRNationalIDV2";
    KnownPiiCategory["GRTaxIdentificationNumber"] = "GRTaxIdentificationNumber";
    KnownPiiCategory["HKIdentityCardNumber"] = "HKIdentityCardNumber";
    KnownPiiCategory["HUValueAddedNumber"] = "HUValueAddedNumber";
    KnownPiiCategory["HUPersonalIdentificationNumber"] = "HUPersonalIdentificationNumber";
    KnownPiiCategory["HUTaxIdentificationNumber"] = "HUTaxIdentificationNumber";
    KnownPiiCategory["INPermanentAccount"] = "INPermanentAccount";
    KnownPiiCategory["INUniqueIdentificationNumber"] = "INUniqueIdentificationNumber";
    KnownPiiCategory["IDIdentityCardNumber"] = "IDIdentityCardNumber";
    KnownPiiCategory["InternationalBankingAccountNumber"] = "InternationalBankingAccountNumber";
    KnownPiiCategory["IEPersonalPublicServiceNumber"] = "IEPersonalPublicServiceNumber";
    KnownPiiCategory["IEPersonalPublicServiceNumberV2"] = "IEPersonalPublicServiceNumberV2";
    KnownPiiCategory["ILBankAccountNumber"] = "ILBankAccountNumber";
    KnownPiiCategory["ILNationalID"] = "ILNationalID";
    KnownPiiCategory["ITDriversLicenseNumber"] = "ITDriversLicenseNumber";
    KnownPiiCategory["ITFiscalCode"] = "ITFiscalCode";
    KnownPiiCategory["ITValueAddedTaxNumber"] = "ITValueAddedTaxNumber";
    KnownPiiCategory["JPBankAccountNumber"] = "JPBankAccountNumber";
    KnownPiiCategory["JPDriversLicenseNumber"] = "JPDriversLicenseNumber";
    KnownPiiCategory["JPPassportNumber"] = "JPPassportNumber";
    KnownPiiCategory["JPResidentRegistrationNumber"] = "JPResidentRegistrationNumber";
    KnownPiiCategory["JPSocialInsuranceNumber"] = "JPSocialInsuranceNumber";
    KnownPiiCategory["JPMyNumberCorporate"] = "JPMyNumberCorporate";
    KnownPiiCategory["JPMyNumberPersonal"] = "JPMyNumberPersonal";
    KnownPiiCategory["JPResidenceCardNumber"] = "JPResidenceCardNumber";
    KnownPiiCategory["LVPersonalCode"] = "LVPersonalCode";
    KnownPiiCategory["LTPersonalCode"] = "LTPersonalCode";
    KnownPiiCategory["LUNationalIdentificationNumberNatural"] = "LUNationalIdentificationNumberNatural";
    KnownPiiCategory["LUNationalIdentificationNumberNonNatural"] = "LUNationalIdentificationNumberNonNatural";
    KnownPiiCategory["MYIdentityCardNumber"] = "MYIdentityCardNumber";
    KnownPiiCategory["MTIdentityCardNumber"] = "MTIdentityCardNumber";
    KnownPiiCategory["MTTaxIDNumber"] = "MTTaxIDNumber";
    KnownPiiCategory["NLCitizensServiceNumber"] = "NLCitizensServiceNumber";
    KnownPiiCategory["NLCitizensServiceNumberV2"] = "NLCitizensServiceNumberV2";
    KnownPiiCategory["NLTaxIdentificationNumber"] = "NLTaxIdentificationNumber";
    KnownPiiCategory["NLValueAddedTaxNumber"] = "NLValueAddedTaxNumber";
    KnownPiiCategory["NZBankAccountNumber"] = "NZBankAccountNumber";
    KnownPiiCategory["NZDriversLicenseNumber"] = "NZDriversLicenseNumber";
    KnownPiiCategory["NZInlandRevenueNumber"] = "NZInlandRevenueNumber";
    KnownPiiCategory["NZMinistryOfHealthNumber"] = "NZMinistryOfHealthNumber";
    KnownPiiCategory["NZSocialWelfareNumber"] = "NZSocialWelfareNumber";
    KnownPiiCategory["NOIdentityNumber"] = "NOIdentityNumber";
    KnownPiiCategory["PHUnifiedMultiPurposeIDNumber"] = "PHUnifiedMultiPurposeIDNumber";
    KnownPiiCategory["PLIdentityCard"] = "PLIdentityCard";
    KnownPiiCategory["PLNationalID"] = "PLNationalID";
    KnownPiiCategory["PLNationalIDV2"] = "PLNationalIDV2";
    KnownPiiCategory["PLPassportNumber"] = "PLPassportNumber";
    KnownPiiCategory["PLTaxIdentificationNumber"] = "PLTaxIdentificationNumber";
    KnownPiiCategory["PlregonNumber"] = "PLREGONNumber";
    KnownPiiCategory["PTCitizenCardNumber"] = "PTCitizenCardNumber";
    KnownPiiCategory["PTCitizenCardNumberV2"] = "PTCitizenCardNumberV2";
    KnownPiiCategory["PTTaxIdentificationNumber"] = "PTTaxIdentificationNumber";
    KnownPiiCategory["ROPersonalNumericalCode"] = "ROPersonalNumericalCode";
    KnownPiiCategory["RUPassportNumberDomestic"] = "RUPassportNumberDomestic";
    KnownPiiCategory["RUPassportNumberInternational"] = "RUPassportNumberInternational";
    KnownPiiCategory["SANationalID"] = "SANationalID";
    KnownPiiCategory["SGNationalRegistrationIdentityCardNumber"] = "SGNationalRegistrationIdentityCardNumber";
    KnownPiiCategory["SKPersonalNumber"] = "SKPersonalNumber";
    KnownPiiCategory["SITaxIdentificationNumber"] = "SITaxIdentificationNumber";
    KnownPiiCategory["SIUniqueMasterCitizenNumber"] = "SIUniqueMasterCitizenNumber";
    KnownPiiCategory["ZAIdentificationNumber"] = "ZAIdentificationNumber";
    KnownPiiCategory["KRResidentRegistrationNumber"] = "KRResidentRegistrationNumber";
    KnownPiiCategory["Esdni"] = "ESDNI";
    KnownPiiCategory["ESSocialSecurityNumber"] = "ESSocialSecurityNumber";
    KnownPiiCategory["ESTaxIdentificationNumber"] = "ESTaxIdentificationNumber";
    KnownPiiCategory["SQLServerConnectionString"] = "SQLServerConnectionString";
    KnownPiiCategory["SENationalID"] = "SENationalID";
    KnownPiiCategory["SENationalIDV2"] = "SENationalIDV2";
    KnownPiiCategory["SEPassportNumber"] = "SEPassportNumber";
    KnownPiiCategory["SETaxIdentificationNumber"] = "SETaxIdentificationNumber";
    KnownPiiCategory["SwiftCode"] = "SWIFTCode";
    KnownPiiCategory["CHSocialSecurityNumber"] = "CHSocialSecurityNumber";
    KnownPiiCategory["TWNationalID"] = "TWNationalID";
    KnownPiiCategory["TWPassportNumber"] = "TWPassportNumber";
    KnownPiiCategory["TWResidentCertificate"] = "TWResidentCertificate";
    KnownPiiCategory["THPopulationIdentificationCode"] = "THPopulationIdentificationCode";
    KnownPiiCategory["TRNationalIdentificationNumber"] = "TRNationalIdentificationNumber";
    KnownPiiCategory["UKDriversLicenseNumber"] = "UKDriversLicenseNumber";
    KnownPiiCategory["UKElectoralRollNumber"] = "UKElectoralRollNumber";
    KnownPiiCategory["UKNationalHealthNumber"] = "UKNationalHealthNumber";
    KnownPiiCategory["UKNationalInsuranceNumber"] = "UKNationalInsuranceNumber";
    KnownPiiCategory["UKUniqueTaxpayerNumber"] = "UKUniqueTaxpayerNumber";
    KnownPiiCategory["UsukPassportNumber"] = "USUKPassportNumber";
    KnownPiiCategory["USBankAccountNumber"] = "USBankAccountNumber";
    KnownPiiCategory["USDriversLicenseNumber"] = "USDriversLicenseNumber";
    KnownPiiCategory["USIndividualTaxpayerIdentification"] = "USIndividualTaxpayerIdentification";
    KnownPiiCategory["USSocialSecurityNumber"] = "USSocialSecurityNumber";
    KnownPiiCategory["UAPassportNumberDomestic"] = "UAPassportNumberDomestic";
    KnownPiiCategory["UAPassportNumberInternational"] = "UAPassportNumberInternational";
    KnownPiiCategory["Organization"] = "Organization";
    KnownPiiCategory["Email"] = "Email";
    KnownPiiCategory["URL"] = "URL";
    KnownPiiCategory["Age"] = "Age";
    KnownPiiCategory["PhoneNumber"] = "PhoneNumber";
    KnownPiiCategory["IPAddress"] = "IPAddress";
    KnownPiiCategory["Date"] = "Date";
    KnownPiiCategory["Person"] = "Person";
    KnownPiiCategory["Address"] = "Address";
    KnownPiiCategory["All"] = "All";
    KnownPiiCategory["Default"] = "Default";
})(KnownPiiCategory || (KnownPiiCategory = {}));
/** Known values of {@link ExtractiveSummarizationTaskParametersSortBy} that the service accepts. */
var KnownExtractiveSummarizationTaskParametersSortBy;
(function (KnownExtractiveSummarizationTaskParametersSortBy) {
    KnownExtractiveSummarizationTaskParametersSortBy["Offset"] = "Offset";
    KnownExtractiveSummarizationTaskParametersSortBy["Rank"] = "Rank";
})(KnownExtractiveSummarizationTaskParametersSortBy || (KnownExtractiveSummarizationTaskParametersSortBy = {}));
/** Known values of {@link ErrorCodeValue} that the service accepts. */
var KnownErrorCodeValue;
(function (KnownErrorCodeValue) {
    KnownErrorCodeValue["InvalidRequest"] = "InvalidRequest";
    KnownErrorCodeValue["InvalidArgument"] = "InvalidArgument";
    KnownErrorCodeValue["InternalServerError"] = "InternalServerError";
    KnownErrorCodeValue["ServiceUnavailable"] = "ServiceUnavailable";
    KnownErrorCodeValue["NotFound"] = "NotFound";
})(KnownErrorCodeValue || (KnownErrorCodeValue = {}));
(function (KnownInnerErrorCodeValue) {
    KnownInnerErrorCodeValue["InvalidParameterValue"] = "InvalidParameterValue";
    KnownInnerErrorCodeValue["InvalidRequestBodyFormat"] = "InvalidRequestBodyFormat";
    KnownInnerErrorCodeValue["EmptyRequest"] = "EmptyRequest";
    KnownInnerErrorCodeValue["MissingInputRecords"] = "MissingInputRecords";
    KnownInnerErrorCodeValue["InvalidDocument"] = "InvalidDocument";
    KnownInnerErrorCodeValue["ModelVersionIncorrect"] = "ModelVersionIncorrect";
    KnownInnerErrorCodeValue["InvalidDocumentBatch"] = "InvalidDocumentBatch";
    KnownInnerErrorCodeValue["UnsupportedLanguageCode"] = "UnsupportedLanguageCode";
    KnownInnerErrorCodeValue["InvalidCountryHint"] = "InvalidCountryHint";
})(exports.KnownInnerErrorCodeValue || (exports.KnownInnerErrorCodeValue = {}));
(function (KnownWarningCode) {
    KnownWarningCode["LongWordsInDocument"] = "LongWordsInDocument";
    KnownWarningCode["DocumentTruncated"] = "DocumentTruncated";
})(exports.KnownWarningCode || (exports.KnownWarningCode = {}));
(function (KnownHealthcareEntityCategory) {
    KnownHealthcareEntityCategory["BodyStructure"] = "BODY_STRUCTURE";
    KnownHealthcareEntityCategory["AGE"] = "AGE";
    KnownHealthcareEntityCategory["Gender"] = "GENDER";
    KnownHealthcareEntityCategory["ExaminationName"] = "EXAMINATION_NAME";
    KnownHealthcareEntityCategory["Date"] = "DATE";
    KnownHealthcareEntityCategory["Direction"] = "DIRECTION";
    KnownHealthcareEntityCategory["Frequency"] = "FREQUENCY";
    KnownHealthcareEntityCategory["MeasurementValue"] = "MEASUREMENT_VALUE";
    KnownHealthcareEntityCategory["MeasurementUnit"] = "MEASUREMENT_UNIT";
    KnownHealthcareEntityCategory["RelationalOperator"] = "RELATIONAL_OPERATOR";
    KnownHealthcareEntityCategory["Time"] = "TIME";
    KnownHealthcareEntityCategory["GeneORProtein"] = "GENE_OR_PROTEIN";
    KnownHealthcareEntityCategory["Variant"] = "VARIANT";
    KnownHealthcareEntityCategory["AdministrativeEvent"] = "ADMINISTRATIVE_EVENT";
    KnownHealthcareEntityCategory["CareEnvironment"] = "CARE_ENVIRONMENT";
    KnownHealthcareEntityCategory["HealthcareProfession"] = "HEALTHCARE_PROFESSION";
    KnownHealthcareEntityCategory["Diagnosis"] = "DIAGNOSIS";
    KnownHealthcareEntityCategory["SymptomORSign"] = "SYMPTOM_OR_SIGN";
    KnownHealthcareEntityCategory["ConditionQualifier"] = "CONDITION_QUALIFIER";
    KnownHealthcareEntityCategory["MedicationClass"] = "MEDICATION_CLASS";
    KnownHealthcareEntityCategory["MedicationName"] = "MEDICATION_NAME";
    KnownHealthcareEntityCategory["Dosage"] = "DOSAGE";
    KnownHealthcareEntityCategory["MedicationForm"] = "MEDICATION_FORM";
    KnownHealthcareEntityCategory["MedicationRoute"] = "MEDICATION_ROUTE";
    KnownHealthcareEntityCategory["FamilyRelation"] = "FAMILY_RELATION";
    KnownHealthcareEntityCategory["TreatmentName"] = "TREATMENT_NAME";
})(exports.KnownHealthcareEntityCategory || (exports.KnownHealthcareEntityCategory = {}));
/** Known values of {@link RelationType} that the service accepts. */
var KnownRelationType;
(function (KnownRelationType) {
    KnownRelationType["Abbreviation"] = "Abbreviation";
    KnownRelationType["DirectionOfBodyStructure"] = "DirectionOfBodyStructure";
    KnownRelationType["DirectionOfCondition"] = "DirectionOfCondition";
    KnownRelationType["DirectionOfExamination"] = "DirectionOfExamination";
    KnownRelationType["DirectionOfTreatment"] = "DirectionOfTreatment";
    KnownRelationType["DosageOfMedication"] = "DosageOfMedication";
    KnownRelationType["FormOfMedication"] = "FormOfMedication";
    KnownRelationType["FrequencyOfMedication"] = "FrequencyOfMedication";
    KnownRelationType["FrequencyOfTreatment"] = "FrequencyOfTreatment";
    KnownRelationType["QualifierOfCondition"] = "QualifierOfCondition";
    KnownRelationType["RelationOfExamination"] = "RelationOfExamination";
    KnownRelationType["RouteOfMedication"] = "RouteOfMedication";
    KnownRelationType["TimeOfCondition"] = "TimeOfCondition";
    KnownRelationType["TimeOfEvent"] = "TimeOfEvent";
    KnownRelationType["TimeOfExamination"] = "TimeOfExamination";
    KnownRelationType["TimeOfMedication"] = "TimeOfMedication";
    KnownRelationType["TimeOfTreatment"] = "TimeOfTreatment";
    KnownRelationType["UnitOfCondition"] = "UnitOfCondition";
    KnownRelationType["UnitOfExamination"] = "UnitOfExamination";
    KnownRelationType["ValueOfCondition"] = "ValueOfCondition";
    KnownRelationType["ValueOfExamination"] = "ValueOfExamination";
})(KnownRelationType || (KnownRelationType = {}));

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.TextAnalyticsClient = TextAnalyticsClient;
//# sourceMappingURL=index.js.map
